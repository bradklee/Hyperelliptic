\\Title: A Picard-Fuchs Algorithm for Hyperelliptic Level Curves.
\\Author: Bradley Klee.
\\License: GPLv3.

\\Input: Polynomial potential function V(x)
\\Output: One-form reduction matrices
{HyperEllipticData(poly)=
my(deg,Gx,GL,GR,ID,InvG);
deg=poldegree(poly,x);
Gz=matrix(2*deg-1,2*deg-1,j,k,if(j==k&&k<deg,z,0));
GL=matrix(2*deg-1,2*deg-1,j,k,if(0<j-k&&j-k<=deg&&k<deg,-2*polcoef(poly,j-k),0));
GR=matrix(2*deg-1,2*deg-1,j,k,if(k>=deg&&j-(k-deg)>0&&j-(k-deg)<=deg,-(j-(k-deg))*polcoef(poly,j-(k-deg)),0));
ID=matrix(2*deg-1,2*deg-1,j,k,if(j==k,1,0));
InvG=matinverseimage(Gz+GL+GR,ID);
MU=matrix(deg-1,deg-1,j,k,InvG[j,k]);
MV=matrix(deg,deg-1,j,k,InvG[j+deg-1,k]);
dMV=matrix(deg-1,deg-1,j,k,j*MV[j+1,k]);
[deg,MU,MV,dMV]};

\\Input: One-form and One-form reduction matrices
\\Output: Certified, hermite-reduced one form 
{HermiteReduce(dtform,cert,dat,n)=if(n==0,[dtform,cert],
HermiteReduce((dat[2]+1/(2*n-1)*dat[4])*dtform,
cert+1/((2*n-1)*y^(2*n-1))*dat[3]*dtform,
dat,n-1))};

\\n!!
{DoubleFactorial(n) = prod(i=0, (n-1)\2, n - 2*i )};

\\Input: Parity Boolean, one-form reduction matrices
\\Output: Raw Picard-Fuchs data
{PeriodBasis(sym,dat)=
my(d,dt,bound,reduction);
d=dat[1];
dt=vector(d-1,j,if(j==1,1,0))~;
bound=2*if(sym==0,floor((d-1)/2),floor(d/4));
decomposition=concat([[dt,vector(dat[1],j,0)~]],
vector(bound,j,HermiteReduce(((-1/2)^j)*DoubleFactorial(2*j-1)*dt,0,dat,j)));
[vector(bound+1,j,decomposition[j][1]),
vector(bound+1,j,vector(dat[1],j,x^(j-1))*decomposition[j][2]),
concat([1],vector(bound,j,((-1/(2*y^2))^(j)*DoubleFactorial(2*j-1))))]};

\\Input: Polynomial Potential Function V(x)
\\Output: Processed Picard-Fuchs data
{HyperellipticPicardFuchs(poly)=
my(HEDat,sym,decomposition,PFCs);
sym=if(subst(poly,x,-x)-poly==0,1,0);
HEDat = HyperEllipticData(poly);
decomposition = PeriodBasis(sym,HEDat);
PFCs=lindep(decomposition[1]);
[(1/2)*y^2+poly,decomposition[3]*dt,PFCs,decomposition[2]*PFCs]};

\\Input: Processed Picard-Fuchs data
\\Output: Boolean check value 0
{CheckCertificate(PFData)=
y^(2*length(PFData[2])-2)*(
deriv(PFData[4],x)*deriv(PFData[1],y)
+deriv(PFData[4],y)*deriv(-PFData[1],x)
+PFData[2]*PFData[3]/dt)%(2*PFData[1]-z)
};

\\(Cf. OEIS: A113424 )
PFData = HyperellipticPicardFuchs((1/2)*(x^2-(1/4)*x^4));
[PFData[3],CheckCertificate(PFData)]

\\(Cf. OEIS: A000897 )
PFData = HyperellipticPicardFuchs((1/2)*(x^2-c*x^3));
[-vector(3,j,9/4*(polcoef(PFData[3][j],2,c)*4/27+polcoef(PFData[3][j],0,c))),CheckCertificate(PFData)]

\\(Cf. OEIS: A113424 )
PFData = HyperellipticPicardFuchs((1/2)*(x^2-(4/27)*x^6));
[-PFData[3],CheckCertificate(PFData)]

\\two-parameter elliptic stratum 
PFData = HyperellipticPicardFuchs((1/2)*(x^2+a*x^3+b*x^4));
[PFData[3],CheckCertificate(PFData)]

\\genus-degree formula: g = floor((d-1)/2) .
\\for d=3,4,5,6... ; g=1,1,2,2...  
v=[];
for(d=3,8,{
PFData = HyperellipticPicardFuchs((1/2)*(x^2+x^3+x^d));
v=concat(v,[[d,(length(PFData[3])-1)/2,CheckCertificate(PFData)]])
})
v

\\apparent genus-degree formula: g' = floor(d/4) .
\\for d=4,6,8,10... ; g=1,1,2,2...  
v=[];
for(d=2,7,{
PFData = HyperellipticPicardFuchs((1/2)*(x^2+x^(2*d)));
v=concat(v,[[d,(length(PFData[3])-1)/2,CheckCertificate(PFData)]])
})
v

\\Parity symmetry allows quotient decomposition of the Riemann surface into two equal pieces, how neat!
